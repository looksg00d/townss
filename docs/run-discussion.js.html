<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: run-discussion.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: run-discussion.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>require('dotenv').config(); // Загружаем переменные окружения
const path = require('path');

// Глобальные обработчики ошибок
process.on('uncaughtException', (err) => {
  console.error('Uncaught Exception occurred:\n', err);
  console.error(err.stack);
  process.exit(1);
});
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
  if (reason &amp;&amp; reason.stack) {
    console.error(reason.stack);
  }
  process.exit(1);
});

const config = require('./config/config');
const logger = require('./services/logger').withLabel('run-');
const OpenAIService = require('./services/r_openaiservice');
const CharacterService = require('./services/r_characterservice');
const ResponseGeneratorService = require('./services/r_responsegeneratorservice');
const DataFetchService = require('./services/r_datafetchservice');
const InsightReaderService = require('./services/r_insightreaderservice');
const InsightService = require('./services/r_insightservice');
const PublicationService = require('./services/r_publicationservice');
const ProfileService = require('./services/r_profileservice');
const DiscussionService = require('./services/r_discussionservice');
const TelegramService = require('./services/TT_telegramservice');
const delay = require('./services/delay');
const { loadProfiles } = require('./profiles');
const characterService = new CharacterService({ logger });

// Импортируйте FileService
const FileService = require('./services/fileservice');

/**
 * Запускает обсуждение для указанного инсайта.
 * @param {number} insightId - Идентификатор инсайта.
 * @returns {Promise&lt;void>} Промис, который завершается после завершения обсуждения.
 * @throws {Error} Если инсайт не найден или произошла ошибка.
 */
async function runDiscussion(insightId) {
    console.log("Запускаем runDiscussion с insightId:", insightId);
    try {
        logger.info('=== Starting Discussion ===');

        // Инициализация OpenAI с конфигурацией
        logger.info('Initializing OpenAI service...');
        const openAIService = new OpenAIService({
            apiKey: process.env.GROQ_API_KEY,
            logger
        });
        const openai = openAIService.getClient();
        logger.debug(`OpenAI API Key: ${process.env.GROQ_API_KEY}`);
        console.log("После инициализации OpenAIService");

        logger.debug('OpenAI client initialized:', {
            client: openai,
            type: typeof openai
        });

        // Инициализация Apify клиента
        const Apify = require('apify-client').ApifyClient;
        const apifyClient = new Apify({
            token: config.apify.token
        });

        // Инициализация FileService
        const fileService = new FileService();

        // Инициализация сервисов с внедрением зависимостей
        const dataFetchService = new DataFetchService({
            apifyClient,
            openAI: openai,
            logger
        });

        const insightReaderService = new InsightReaderService({
            logger,
            config,
            fileService
        });

        const responseGenerator = new ResponseGeneratorService({
            openAI: openai,
            dataFetchService,
            logger,
            config
        });

        logger.debug('ResponseGeneratorService initialized:', {
            openai: responseGenerator.openai
        });

        const characterService = new CharacterService({ logger });
        const insightService = new InsightService({
            insightReaderService,
            logger
        });

        const publicationService = new PublicationService({ logger });
        const profileService = new ProfileService({
            loadProfiles,
            logger
        });
        await profileService.initialize();

        const discussionServiceInstance = new DiscussionService({
            characterService,
            responseGenerator,
            logger,
            config,
            profileService
        });

        // Загружаем профили
        const profiles = await loadProfiles(); // Добавлено: загружаем профили
        logger.debug(`Loaded profiles: ${JSON.stringify(profiles)}`);

        // Получение инсайта
        logger.info(`Fetching insight with ID: ${insightId}`);
        const insight = await insightService.getInsight(insightId);
        logger.debug(`Retrieved insight: ${JSON.stringify(insight)}`);

        // Явно вызываем загрузку персонажей
        await characterService.loadCharacters(process.env.CHARACTERS_PATH); 
        // Публикация инсайта от имени основного персонажа
        const mainCharacter = characterService.getMainCharacter(); // Получаем основного персонажа
        console.log(mainCharacter); 
        const mainProfileId = Object.keys(profiles).find(profileId => profiles[profileId].character === mainCharacter.username);
        if (!mainProfileId) { 
            throw new Error(`Профиль для персонажа ${mainCharacter.username} не найден`);
        }
        logger.info(`Publishing insight as ${mainProfileId}`);
        await publicationService.publishInsight(mainProfileId, insightId);

        // Пауза между сообщениями (5-10 секунд)
        const pause = 5000 + Math.random() * 5000;
        logger.info(`Pausing for ${pause} milliseconds...`);
        await delay(pause);

        // Выбор случайного профиля для ответа
        logger.info('Selecting a random responder');
        const responder = profileService.selectRandomResponder(mainProfileId);

        // Генерация ответа от выбранного профиля
        logger.info('Generating response from selected character');
        const response = await responseGenerator.generateResponse(
            responder.characterObj, 
            insight.content
        );
        logger.debug(`Generated response: ${response}`);

        // Публикуем ответ
        logger.info('Publishing the generated response');
        await publicationService.publishResponse(responder.id, response);

        logger.info('=== Discussion Successfully Completed ===');
    } catch (error) {
        logger.error('An error occurred during the discussion process');
        if (
            error.name === 'InsightNotFoundError' ||
            error.name === 'NoAvailableProfilesError' ||
            error.name === 'ResponseGenerationError'
        ) {
            logger.error(`Handled Error: ${error.message}`);
        } else {
            logger.error(`Unhandled Error: ${error.message}`);
            if (error.stack) {
                logger.debug(`Stack Trace: ${error.stack}`);
            }
        }
        // Завершаем процесс с ненулевым кодом
        process.exit(1);
    }
}

async function processInsights(insights) {
    try {
        logger.info(`Начинаем обработку ${insights.length} инсайтов`);

        for (const insight of insights) {
            try {
                logger.info(`Обработка инсайта: ${insight.id}`);
                await runDiscussion(insight.id);

                // Пауза между обработкой инсайтов
                const pause = 30000 + Math.random() * 30000; // 30-60 секунд
                logger.info(`Пауза перед следующим инсайтом: ${pause} мс`);
                await delay(pause);

            } catch (error) {
                logger.error(`Ошибка при обработке инсайта ${insight.id}:`, error);
                // Продолжаем обработку следующих инсайтов
            }
        }

        logger.info('Все инсайты успешно обработаны');
    } catch (error) {
        logger.error('Критическая ошибка при обработке инсайтов:', error);
        throw error;
    }
}

// Запуск скрипта
if (require.main === module) {
    const insightIdArg = process.argv[2];
    const insightId = insightIdArg ? parseInt(insightIdArg, 10) : null;

    if (insightIdArg &amp;&amp; isNaN(insightId)) {
        logger.error('The insight ID must be a number!');
        logger.info('Usage: node run-discussion.js &lt;insightId>');
        process.exit(1);
    }

    if (!insightId) {
        logger.error('An insight ID must be provided!');
        logger.info('Usage: node run-discussion.js &lt;insightId>');
        process.exit(1);
    }

    runDiscussion(insightId).catch(error => {
        logger.error(`Script terminated with error: ${error.message}`);
        process.exit(1);
    });
}

module.exports = { runDiscussion };
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="DataFetchService.html">DataFetchService</a></li><li><a href="ProfileService.html">ProfileService</a></li><li><a href="ResponseGeneratorService.html">ResponseGeneratorService</a></li></ul><h3>Global</h3><ul><li><a href="global.html#collectAllData">collectAllData</a></li><li><a href="global.html#collectCryptoChatAlphaInsights">collectCryptoChatAlphaInsights</a></li><li><a href="global.html#collectCryptoChatPosts">collectCryptoChatPosts</a></li><li><a href="global.html#collectTownsCharacters">collectTownsCharacters</a></li><li><a href="global.html#runDiscussion">runDiscussion</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sat Feb 15 2025 23:41:24 GMT+0300 (Moscow Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
